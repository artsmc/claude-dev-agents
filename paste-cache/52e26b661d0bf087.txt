I’m going to (1) clearly define what Mode 1 vs Mode 2 are in your `/start-phase` system, then (2) break Mode 2 into Part 1–5 with concrete outputs, folder/files, and what “task-updates / agent-delegation / phase-structure” specifically contain.


Below is a clean breakdown of what you’ve described, with **Mode 1 (Plan Mode)** and **Mode 2 (Act Mode)** separated, and then a **Part 2–5 breakdown** that matches the intent of your doc (even though your snippet explicitly details Parts 1–4).

---

## Mode 1 — Human-in-the-loop + Refine Task

### What Mode 1 *is*

Mode 1 is the **strategic gate**. The system is not allowed to start building yet. It’s forced to **think like a phase manager**: reduce scope, make tasks parallel, and ensure incremental integration.

### Primary purpose

* **Human approval checkpoint**
* **Refine the task list** so the execution phase doesn’t become a messy “big bang” build
* **Force parallelism + incremental builds**

### Inputs Mode 1 reads

* The provided `task_list_file` (e.g., `task-list.md`)
* Documentation Hub (`{{input_folder}}/docs` or whatever your hub is)
* Memory Bank (your project memory / operating rules)

### What Mode 1 produces (deliverables)

**A revised task list** proposed back to the user, optimized for:

* smallest working prototype first
* independent task “chunks”
* clear dependencies
* parallelizable work units
* explicit “definition of done” per task

### Human-in-the-loop behavior

Mode 1 ends only when the user explicitly approves the refined plan.

**Key rule:** no directories, no commits, no code changes—only planning and negotiation.

---

## Mode 2 — Finalize Plan + Execute With Structure

Mode 2 is where the plan becomes “official” and execution begins. It’s structured so you always know:

* what changed,
* who did it,
* what files were impacted,
* what got committed,
* and what remains.

### Mode 2 is organized around three planning folders

Inside `{{input_folder}}/planning/`:

1. **`task-updates/`**

* A growing log of completed work.
* One markdown file per task.

2. **`agent-delegation/`**

* How tasks are mapped to sub-agents / personas.
* Includes the “parallel execution instruction”.

3. **`phase-structure/`**

* System-level view of what’s being changed.
* File impact + relationships + SLOC tracking.

---

# Mode 2: Part-by-part breakdown

## Part 1 — Finalize Plan (Lock it in) + Create Directories

### Goal

Turn the approved plan into the single source of truth, and create the scaffold that will hold execution artifacts.

### Outputs

1. **Programmatic update** of `<task_list_file>` (the “approved plan” is now the official plan)
2. Directory creation:

* `{{input_folder}}/planning/task-updates/`
* `{{input_folder}}/planning/agent-delegation/`
* `{{input_folder}}/planning/phase-structure/`

### Why this exists

This is what makes the rest of the phase auditable and repeatable.

---

## Part 2 — Detailed Planning & Analysis (Create the 3 planning docs)

This part creates the *execution brain* of the phase.

### 2.1 Task Delegation (`agent-delegation/task-delegation.md`)

**What it is**

* A task-to-agent assignment map.

**Must include**

* Mermaid `graph TD`
* Each task labeled with:

  * assigned agent persona
  * priority
  * difficulty
  * dependencies (if any)

**Why**
So parallelization is real, not “vibes”. Everyone knows what they own.

---

### 2.2 Sub-Agent Parallel Plan (`agent-delegation/sub-agent-plan.md`)

**What it is**

* The explicit runbook for parallel execution.

**Must include**

* A literal instruction like:

  * **“Spawn SUBAGENT WORKERS IN PARALLEL to complete these tasks.”**

**Why**
This is your “parallel switch” — it makes the system commit to concurrency rather than drifting back into serial execution.

---

### 2.3 System Changes Analysis (`phase-structure/system-changes.md`)

**What it is**

* The architectural impact report.

**Must include**

1. **Mermaid flowchart** of impacted files and relationships
2. **SLOC table** (baseline tracking per file)

**Why**
This gives you:

* blast-radius visibility
* review efficiency
* a way to detect scope creep instantly

✅ **Part 2 ends only when all three files exist.**

---

## Part 3 — Parallel Task Execution (Do the work)

### Goal

Execute tasks according to the delegation plan, using sub-agents where possible.

### What “execution” must look like

* Announce:

  * what task is starting
  * what persona is being used (e.g., `nextjs-backend-developer`)
* When tasks can run concurrently, invoke the instruction from `sub-agent-plan.md`, e.g.:

  * **“Spawn SUBAGENT WORKERS IN PARALLEL…”**

### Why

This is the “build” phase, but it stays disciplined because the plan + delegation documents are already locked.

---

## Part 4 — Task Updates + Commits + Final Review

### 4.1 Task updates (writes into `planning/task-updates/`)

For **each completed task**, create a markdown file like:

* `planning/task-updates/<task-name>.md`

**Each update should capture**

* what changed
* files touched
* how to test / verify
* what’s next (if anything)
* decisions made (short + explicit)

### 4.2 Git commit after each task

After each task update file:

```bash
git add .
git commit -m "Completed task: <task-name> during phase {{phase}}"
```

### 4.3 Final code review

* switch persona to `code_reviewer`
* produce `{{input_folder}}/code-review.md`

**code-review.md should include**

* summary of changes
* risk areas
* test coverage / verification notes
* any follow-up tasks suggested

---

## Part 5 — Phase Closeout (Recommended extension)

Your snippet stops at Part 4, but you asked for **Part 2–5 breakdown**, so here’s the missing “Part 5” that completes the workflow cleanly.

### Part 5 goal

Wrap the phase in a way that makes it easy to hand off, audit later, or start the next phase.

### Suggested outputs

1. **Phase completion summary**

* `{{input_folder}}/planning/phase-structure/phase-summary.md`

  * what was delivered
  * what was deferred
  * notable decisions
  * known risks

2. **Next-phase seeds**

* `{{input_folder}}/planning/phase-structure/next-phase-candidates.md`

  * backlog items discovered during execution
  * technical debt notes
  * improvements

3. **SLOC delta (optional but powerful)**

* Append to `system-changes.md`:

  * baseline SLOC vs final SLOC
  * net change per file

### Why Part 5 is worth it

It prevents the classic failure mode: “we finished the phase but nobody knows what actually happened.”

---

## Quick mapping to your bullet list

* **Mode 1**

  * ✅ human in the loop
  * ✅ refine task

* **Mode 2**

  * ✅ finalize plan
  * ✅ task-updates (Part 4)
  * ✅ agent-delegation (Part 2)
  * ✅ phase-structure (Part 2)
  * ✅ Part 2–5 breakdown (above)

---

If you want, I can rewrite your original spec into a tighter “single page operational doc” where **Part 5 is formally added** and all required files are listed in one checklist.
