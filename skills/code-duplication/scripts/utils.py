#!/usr/bin/env python3
"""
Utility Functions for Code Duplication Analysis Skill

Shared utility functions used across multiple modules in the skill.
Provides file handling, formatting, and common operations.
"""

import re
from pathlib import Path
from typing import Optional, Set
import mimetypes


# Common comment patterns for different languages
COMMENT_PATTERNS = {
    'python': [
        re.compile(r'^\s*#'),  # Line comments
        re.compile(r'^\s*"""'),  # Docstring start
        re.compile(r'"""$'),  # Docstring end
        re.compile(r"^\s*'''"),  # Single quote docstring start
        re.compile(r"'''$"),  # Single quote docstring end
    ],
    'javascript': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
    'typescript': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
    'java': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
    'go': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
    'rust': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
    'cpp': [
        re.compile(r'^\s*//'),  # Line comments
        re.compile(r'^\s*/\*'),  # Block comment start
        re.compile(r'\*/$'),  # Block comment end
    ],
}


# Patterns indicating generated code
GENERATED_FILE_PATTERNS = [
    re.compile(r'@generated', re.IGNORECASE),
    re.compile(r'auto-generated', re.IGNORECASE),
    re.compile(r'autogenerated', re.IGNORECASE),
    re.compile(r'do not edit', re.IGNORECASE),
    re.compile(r'generated by', re.IGNORECASE),
    re.compile(r'code generator', re.IGNORECASE),
]


def count_lines(file_path: Path, language: Optional[str] = None) -> int:
    """
    Count non-blank, non-comment lines of code in a file.

    Args:
        file_path: Path to source file
        language: Programming language (for comment detection)

    Returns:
        Number of non-blank, non-comment lines

    Raises:
        IOError: If file cannot be read
    """
    try:
        content = safe_read_file(file_path)
    except Exception:
        return 0

    lines = content.split('\n')
    loc = 0
    in_block_comment = False

    # Get comment patterns for language
    patterns = COMMENT_PATTERNS.get(language or '', [])

    for line in lines:
        stripped = line.strip()

        # Skip blank lines
        if not stripped:
            continue

        # Check for block comment delimiters
        if language in ['javascript', 'typescript', 'java', 'go', 'rust', 'cpp']:
            if '/*' in stripped:
                in_block_comment = True
            if '*/' in stripped:
                in_block_comment = False
                continue

        # Skip if in block comment
        if in_block_comment:
            continue

        # Check for line comments
        is_comment = False
        for pattern in patterns:
            if pattern.match(stripped):
                is_comment = True
                break

        if not is_comment:
            loc += 1

    return loc


def is_text_file(path: Path) -> bool:
    """
    Determine if a file is likely a text file (not binary).

    Uses multiple heuristics:
    1. MIME type detection
    2. File extension
    3. Magic number detection (reads first few bytes)

    Args:
        path: Path to file

    Returns:
        True if file appears to be text, False if binary
    """
    # Check MIME type
    mime_type, _ = mimetypes.guess_type(str(path))
    if mime_type:
        if mime_type.startswith('text/'):
            return True
        if mime_type.startswith('image/'):
            return False
        if mime_type in ['application/pdf', 'application/zip', 'application/x-executable']:
            return False

    # Check common text file extensions
    text_extensions = {
        '.txt', '.md', '.rst', '.log', '.csv', '.json', '.xml', '.yaml', '.yml',
        '.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.go', '.rs', '.cpp', '.c',
        '.h', '.hpp', '.cs', '.rb', '.php', '.swift', '.kt', '.scala', '.sh',
        '.bash', '.zsh', '.fish', '.html', '.css', '.scss', '.sass', '.less',
        '.sql', '.r', '.m', '.pl', '.lua', '.vim', '.ini', '.conf', '.toml',
    }
    if path.suffix.lower() in text_extensions:
        return True

    # Check common binary extensions
    binary_extensions = {
        '.exe', '.dll', '.so', '.dylib', '.a', '.o', '.obj', '.bin', '.dat',
        '.pdf', '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg',
        '.mp3', '.mp4', '.avi', '.mov', '.wav', '.flac', '.ogg',
        '.zip', '.tar', '.gz', '.bz2', '.7z', '.rar', '.dmg', '.iso',
        '.pyc', '.pyo', '.class', '.jar', '.war',
    }
    if path.suffix.lower() in binary_extensions:
        return False

    # Read first few bytes to check for null bytes
    try:
        with open(path, 'rb') as f:
            chunk = f.read(8192)  # Read first 8KB
            if b'\x00' in chunk:  # Null byte indicates binary
                return False
            # Check if most bytes are printable ASCII
            printable = sum(1 for byte in chunk if 32 <= byte <= 126 or byte in [9, 10, 13])
            return (printable / len(chunk)) > 0.8 if chunk else True
    except Exception:
        # If we can't read it, assume it's binary
        return False


def is_generated_file(path: Path) -> bool:
    """
    Detect if a file is auto-generated code.

    Checks:
    1. Common generated file patterns in first 50 lines
    2. File path patterns (e.g., __generated__, .generated)

    Args:
        path: Path to file

    Returns:
        True if file appears to be generated, False otherwise
    """
    # Check path patterns
    path_str = str(path).lower()
    if '__generated__' in path_str or '.generated' in path_str:
        return True
    if '/generated/' in path_str or '\\generated\\' in path_str:
        return True

    # Check file content (first 50 lines)
    try:
        content = safe_read_file(path)
        lines = content.split('\n')[:50]  # Only check first 50 lines

        for line in lines:
            for pattern in GENERATED_FILE_PATTERNS:
                if pattern.search(line):
                    return True
    except Exception:
        pass

    return False


def safe_read_file(path: Path, fallback_encoding: str = 'latin-1') -> str:
    """
    Safely read a text file with encoding fallback.

    Tries UTF-8 first, then falls back to specified encoding.

    Args:
        path: Path to file
        fallback_encoding: Encoding to use if UTF-8 fails (default: latin-1)

    Returns:
        File content as string

    Raises:
        IOError: If file cannot be read with either encoding
    """
    # Try UTF-8 first
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return f.read()
    except UnicodeDecodeError:
        pass

    # Fall back to specified encoding
    try:
        with open(path, 'r', encoding=fallback_encoding) as f:
            return f.read()
    except Exception as e:
        raise IOError(f"Cannot read file {path}: {e}")


def format_duration(seconds: float) -> str:
    """
    Format duration in seconds to human-readable string.

    Examples:
        0.5 -> "0.5s"
        45 -> "45.0s"
        90 -> "1.5m"
        3600 -> "1.0h"
        7200 -> "2.0h"

    Args:
        seconds: Duration in seconds

    Returns:
        Formatted duration string
    """
    if seconds < 60:
        return f"{seconds:.1f}s"

    minutes = seconds / 60
    if minutes < 60:
        return f"{minutes:.1f}m"

    hours = minutes / 60
    if hours < 24:
        return f"{hours:.1f}h"

    days = hours / 24
    return f"{days:.1f}d"


def format_path(path: Path, relative_to: Optional[Path] = None) -> str:
    """
    Format file path for display.

    Args:
        path: Path to format
        relative_to: Base path for relative formatting (default: current directory)

    Returns:
        Formatted path string
    """
    if relative_to is None:
        relative_to = Path.cwd()

    try:
        # Try to make relative
        rel_path = path.relative_to(relative_to)
        return str(rel_path)
    except ValueError:
        # Not relative, return absolute
        return str(path.resolve())


def normalize_line_endings(text: str) -> str:
    """
    Normalize line endings to Unix style (\\n).

    Args:
        text: Text with potentially mixed line endings

    Returns:
        Text with normalized line endings
    """
    # Replace CRLF with LF
    text = text.replace('\r\n', '\n')
    # Replace lone CR with LF
    text = text.replace('\r', '\n')
    return text


def remove_whitespace(text: str) -> str:
    """
    Remove all whitespace from text (for normalization).

    Args:
        text: Text to process

    Returns:
        Text with all whitespace removed
    """
    return re.sub(r'\s+', '', text)


def get_file_language(path: Path) -> Optional[str]:
    """
    Determine programming language from file extension.

    Args:
        path: File path

    Returns:
        Language identifier or None if unknown
    """
    extension_map = {
        '.py': 'python',
        '.js': 'javascript',
        '.ts': 'typescript',
        '.jsx': 'javascript',
        '.tsx': 'typescript',
        '.java': 'java',
        '.go': 'go',
        '.rs': 'rust',
        '.cpp': 'cpp',
        '.cc': 'cpp',
        '.cxx': 'cpp',
        '.c': 'c',
        '.h': 'c',
        '.hpp': 'cpp',
        '.cs': 'csharp',
        '.rb': 'ruby',
        '.php': 'php',
        '.swift': 'swift',
        '.kt': 'kotlin',
        '.scala': 'scala',
        '.sh': 'shell',
        '.bash': 'shell',
        '.zsh': 'shell',
    }

    return extension_map.get(path.suffix.lower())


def truncate_string(text: str, max_length: int, suffix: str = "...") -> str:
    """
    Truncate string to maximum length with suffix.

    Args:
        text: String to truncate
        max_length: Maximum length (including suffix)
        suffix: Suffix to add when truncated (default: "...")

    Returns:
        Truncated string
    """
    if len(text) <= max_length:
        return text

    truncate_at = max_length - len(suffix)
    return text[:truncate_at] + suffix


# Export public API
__all__ = [
    "count_lines",
    "is_text_file",
    "is_generated_file",
    "safe_read_file",
    "format_duration",
    "format_path",
    "normalize_line_endings",
    "remove_whitespace",
    "get_file_language",
    "truncate_string",
]
